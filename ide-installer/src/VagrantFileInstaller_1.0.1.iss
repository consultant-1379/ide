; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName "VagrantFileInstaller"
#define MyAppVersion "1.0.1"
#define MyAppPublisher "Ericsson AB"
#define MyAppURL "http://www.ericsson.com/"
#define MyAppExeName "VagrantInstaller.exe"
#define MyUserName "Administrator"
#define MyBaseDir ".."
#define MyVagrantFile "Vagrantfile"

#define MySourceDir "src"
#define MyCertificateDir "cert"
#define MyNirCmdDir "nircmd"
#define My3PPSourceDir "target"
#define MySSH_ConfigDir "ssh_config"
#define MySSHConfigFile "config"
#define MyVBoxName "VirtualBox-*Win.exe"
#define MyVBoxExtentionPackName "*.vbox-extpack"
#define MyIDExcsrv_File "vcxsrv-*.exe"
#define MyIDExcsrv_Dir "XcSrv"
#define MyIDEVBox_Dir "VirtualBox"
#define MyIDEvagrant_File "vagrant*.msi"
#define MyIDEvhdReizer_TargerDir "VhdResizer"
#define MyIDEvhdReizer_File "VhdResizerSetup.msi"
#define MyIDEVMName "ENM_IDE_Base"
#define MyVagrantEnvDir ".vagrant.d"
#define MyVagrantEnvBoxes  MyVagrantEnvDir + "\boxes"
#define MyWin64CurlDir MyBaseDir + My3PPSourceDir + "\mingw64"
#define MyWin32CurlDir MyBaseDir + My3PPSourceDir + "\mingx86"
#define MyIDEInstallerCertificate "IDE_Installer.cer"
#define MyNirCmdEXE "nircmd.exe"
#define MyRunVagrantUpBatch "RunVagrantUp.bat"
#define MyGetVagrantFileBatch "GetVagrantFile.bat"
#define MyLogFileForVagrantUp "OutVagrantUp.log"
#define MyGitBashInstFile "Git*.exe"
#define MyGitBashInstDir "Git"
#define MyRunVBox "C:\Program Files\Oracle\VirtualBox\VirtualBox.exe"
#define MyVBoxDir "C:\Program Files\Oracle\VirtualBox"
#define MyVirtualBoxVMDirName "VirtualBox VMs"
#define MyAppIcoName "ENM_IDE.ico"
#define MyAppIcoDir "ico"
#define MyEricssonValidDrivepath "C:\"         
                           
#define MyRadixIDE_Dir "gitrepos\ide\vagrant"
#define MyIDEVmDevIDE_Dir MyBaseDir + "\" + MySourceDir + "\ide\vagrant" 

#define MyVMDirName MyBaseDir + "\" + MyVirtualBoxVMDirName + "\" + MyIDEVMName
#define MyIDEvboxConfigFile MyIDEVMName + ".vbox"

#define MyVagrantDirEnv  MyBaseDir + "\" + MyVagrantEnvBoxes


#define MyVirtBoxRefInReg "progId_VirtualBox.Shell.vbox"

#define MyTmpDir "C:\Temp"
#define MyLogDir "log"
#define MyVmIDE_RadixDir "\"+MyVirtualBoxVMDirName+"\" + MyIDEVMName + "*"



[Setup]
; SignTool="KSign /d $q[b]Ericsson[/b]$q $q[b]http://www.ericsson.com[/b]$q $f"
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{84EC576F-F43D-4B72-A074-6C164947B8A0}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
VersionInfoVersion=1.0.1
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName=C:\Users\Administrator
DisableProgramGroupPage=yes
OutputBaseFilename={#MyAppName}_{#MyAppVersion}
Compression=lzma
SolidCompression=yes
DiskSpanning=no
SlicesPerDisk=1
DiskSliceSize=736000000
DisableDirPage=yes
ChangesEnvironment=yes
ChangesAssociations = yes
AlwaysRestart = no
UninstallFilesDir={code:NewTargetDir}\uninst
; OutputDir={#MyBaseDir}\{#My3PPSourceDir}
OutputDir={#MyBaseDir}\{#My3PPSourceDir}\{#MyAppName}_{#MyAppVersion}


[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
;//Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked
;//Name: "TaskEntry"; Description: "Start vagrant IDE in desktop mode?"; GroupDescription: "Startup";
;//Name: "gitinstall"; Description: "Install Git on your Windows target PC? (will not affect on Vagrant VM)"; GroupDescription: "Install add-on"; Flags: unchecked

[Registry]
;//Root: HKCU; Subkey: "Environment"; ValueType: expandsz; ValueName: "DISPLAY"; ValueData: "localhost:10.0"
;//Root: HKCU; Subkey: "Environment"; ValueType: string; ValueName: "HOME"; ValueData: "{code:NewTargetUserDir}"
;//Root: HKCU; Subkey: "Environment"; ValueType: string; ValueName: "VAGRANT_DESKTOP"; ValueData: "true"; Tasks: TaskEntry
;//Root: HKLM; Subkey: "SYSTEM\CurrentControlSet\Control\Session Manager\Environment"; ValueType: expandsz; ValueName: "Path"; ValueData: "{olddata};C:\HashiCorp\Vagrant\bin"; Check: NeedsAddPath('C:\HashiCorp\Vagrant\bin')


[UninstallDelete]
;//Type: filesandordirs; Name: "{code:NewTargetDir}\*"

                 
[Files]
;//Source: "{#MyBaseDir}\{#MyVagrantFile}"; DestDir: "{code:NewTargetDir}\{#MyCertificateDir}"; Flags: ignoreversion
Source: "{#MyIDEVmDevIDE_Dir}\{#MyVagrantFile}"; DestDir: "{code:NewTargetUserDir}"; Flags: ignoreversion recursesubdirs createallsubdirs          


;//Source: "{#MyBaseDir}\{#MySourceDir}\{#MySSH_ConfigDir}\{#MySSHConfigFile}"; DestDir: "{code:NewTargetDir}\{#MySSH_ConfigDir}"; Flags: ignoreversion
;//Source: "{#MyBaseDir}\{#My3PPSourceDir}\{#MyNirCmdEXE}"; DestDir: "{code:NewTargetDir}\{#MyNirCmdDir}"; Flags: ignoreversion
;//Source: "{#MyBaseDir}\{#My3PPSourceDir}\{#MyVBoxName}"; DestDir: "{code:NewTargetDir}\{#MyIDEVBox_Dir}"; Flags: ignoreversion; AfterInstall: RunVBoxInstaller('{code:NewTargetDir}\{#MyIDEVBox_Dir}\{#MyVBoxName}')
;//Source: "{#MyBaseDir}\{#My3PPSourceDir}\{#MyVBoxExtentionPackName}"; DestDir: "{code:NewTargetDir}\{#MyIDEVBox_Dir}"; Flags: ignoreversion; AfterInstall: RunVBoxPackInstaller('{code:NewTargetDir}\{#MyIDEVBox_Dir}\{#MyVBoxExtentionPackName}');

;;Source: "{#MyBaseDir}\{#MySourceDir}\{#MyWin64CurlDir}\*"; DestDir: "{code:NewTargetDir}\{#MyWin64CurlDir}"; Flags: ignoreversion recursesubdirs
;;Source: "{#MyBaseDir}\{#MySourceDir}\{#MyWin32CurlDir}\*"; DestDir: "{code:NewTargetDir}\{#MyWin32CurlDir}"; Flags: ignoreversion recursesubdirs; AfterInstall: ProgressBar('Install curls exe in progress...',100,100)

;//Source: "{#MyBaseDir}\{#My3PPSourceDir}\{#MyGitBashInstFile}"; DestDir: "{code:NewTargetDir}\{#MyGitBashInstDir}"; Flags: ignoreversion; Tasks: gitinstall; AfterInstall: RunGitInstaller('{code:NewTargetDir}\{#MyGitBashInstDir}\{#MyGitBashInstFile}')

;//Source: "{#MyBaseDir}\{#My3PPSourceDir}\{#MyIDExcsrv_File}"; DestDir: "{code:NewTargetDir}\{#MyIDExcsrv_Dir}"; Flags: ignoreversion recursesubdirs; AfterInstall: RunVcXsrvInstaller('{code:NewTargetDir}\{#MyIDExcsrv_Dir}\{#MyIDExcsrv_File}')



;//Source: "{#MyBaseDir}\{#My3PPSourceDir}\{#MyIDEvagrant_File}"; DestDir: "{code:NewTargetDir}\Vagrant"; Flags: ignoreversion; AfterInstall: RunVagrantInstaller('{code:NewTargetDir}\Vagrant\{#MyIDEvagrant_File}')

;//Source: "{#MyBaseDir}\{#My3PPSourceDir}\{#MyIDEvhdReizer_File}"; DestDir: "{code:NewTargetDir}\{#MyIDEvhdReizer_TargerDir}"; Flags: ignoreversion; AfterInstall: RunVdhResizerInstaller('{code:NewTargetDir}\{#MyIDEvhdReizer_TargerDir}\{#MyIDEvhdReizer_File}')

;//Source: "{#MyBaseDir}\{#MySourceDir}\{#MyAppIcoName}"; DestDir: "{code:NewTargetDir}\{#MyAppIcoDir}"; CopyMode: alwaysoverwrite; Flags: ignoreversion; AfterInstall: PrepareToPerformVagrantUp('{code:NewTargetUserDir}\{#MyRadixIDE_Dir}')

; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Icons]
;Name: "{commonprograms}\{#MyAppName}"; Filename: "{code:NewTargetUserDir}\VirtualBox VMs\{#MyIDEvboxConfigFile}"
;Name: "{commondesktop}\{#MyAppName}"; Filename: "{code:NewTargetDir}\{#MyRunVagrantUpBatch}"; IconFilename: "{code:NewTargetDir}\{#MyAppIcoDir}\{#MyAppIcoName}"; Tasks: desktopicon


[Run]
;Filename: "cmd.exe"; Parameters: ""; Flags: runhidden nowait runasoriginaluser; Check: IsVagrantUpToBePerformed; BeforeInstall: PerformVagrantUp('{code:NewTargetUserDir}\{#MyRadixIDE_Dir}');




[Code]
const
  SM_CXSCREEN = 0;
  SM_CYSCREEN = 1;
  INPUT_MOUSE = 0;
  MOUSEEVENTF_MOVE = $0001;
  MOUSEEVENTF_LEFTDOWN = $0002;
  MOUSEEVENTF_LEFTUP = $0004;
  MOUSEEVENTF_RIGHTDOWN = $0008;
  MOUSEEVENTF_RIGHTUP = $0010;
  MOUSEEVENTF_MIDDLEDOWN = $0020;
  MOUSEEVENTF_MIDDLEUP = $0040;
  MOUSEEVENTF_VIRTUALDESK = $4000;
  MOUSEEVENTF_ABSOLUTE = $8000;
  WM_COMMAND = $0111;
  WM_KEYDOWN = $0100;
  VK_RETURN = 13;
  SIGNUM_LENGTH = 7;
  E_SIGNUM_START_LETTER = 'e';
  MIN_FREE_RAM_REQUIRED = 4073741824;
  MIN_FREE_DISK_SPACE_REQUIRED = 12000;
  SMTO_ABORTIFHUNG = 2;
  WM_WININICHANGE = $001A;
  WM_SETTINGCHANGE = WM_WININICHANGE;
  //ALPHA_CHARS = ['a'..'z','A'..'Z'];
var
  Page:   TWizardPage;
  Button: TNewButton;
  Panel: TPanel;
  StaticText: TNewStaticText;
  RichEditViewer: TRichEditViewer;
  PersonalPage: TInputQueryWizardPage;
  PersonalVagrantUsageDesktopPage: TInputOptionWizardPage;
  SelectDestLocPage: TInputDirWizardPage;
  SelectDestLocUserDir: TInputDirWizardPage;
  strSignum, UserCompany: String;
  strDataDir: String;
  strDefaultPath : String;
  rslt : Boolean;
  ProgressPage: TOutputProgressWizardPage;
  fPerformVagrantUp: Boolean;
  fInstallVBox: Boolean;
  fInstallVBoxExtPack: Boolean;
  fCanPerformVagrantUp: Boolean;
  CancelWithoutPrompt: boolean;
  fInstallGit: boolean;
  
type
  TMouseInput = record
    Itype: DWORD;
    dx: Longint;
    dy: Longint;
    mouseData: DWORD;
    dwFlags: DWORD;
    time: DWORD;
    dwExtraInfo: DWORD;
  end;
  SearchRec = record
    Fill: array[1..21] of byte;
    Attr: byte;
    Time: longint;
    Size: longint;
    Name: String;
  end;
  // the following mapping of the DWORDLONG data type is wrong; 
  // the correct type is a 64-bit unsigned integer which is not
  // available in InnoSetup Pascal Script at this time, so max.
  // values of the following fields will be limited to quite a
  // big reserve of 8589,934.592 GB of RAM; I hope enough for
  // the next versions of Windows :-)
  DWORDLONG = Int64;
  TMemoryStatusEx = record
    dwLength: DWORD;
    dwMemoryLoad: DWORD;
    ullTotalPhys: DWORDLONG;
    ullAvailPhys: DWORDLONG;
    ullTotalPageFile: DWORDLONG;
    ullAvailPageFile: DWORDLONG;
    ullTotalVirtual: DWORDLONG;
    ullAvailVirtual: DWORDLONG;
    ullAvailExtendedVirtual: DWORDLONG;
  end;
  WPARAM = UINT_PTR;
  LPARAM = INT_PTR;
  LRESULT = INT_PTR;


function NewTargetDir(Param: String): String; forward;
function ChangeTargetDir(Param: String): String; forward;
function ChangeTargetUserDir(Param: String): String; forward;
function SendMouseClick(Button: TMouseButton; X, Y: Integer): Boolean; forward;
function NewTargetDrivePath(): String; forward;
function NextButtonClick(CurPageID: Integer): Boolean; forward;
procedure RunGitInstaller(const strFile: String); forward;

function BoolToStr(Value : Boolean) : String; 
begin
  if Value then
    result := 'true'
  else
    result := 'false';
end;

procedure ExitProcess(exitCode: integer);
  external 'ExitProcess@kernel32.dll stdcall';

function GlobalMemoryStatusEx(var lpBuffer: TMemoryStatusEx): BOOL;
  external 'GlobalMemoryStatusEx@kernel32.dll stdcall';



function GetCurrentUserName(): String;
var
  strUsNameWithDomain, strUserName, strLogWmicReult, strUserNameFromReg: String;
  strFileData: AnsiString;
  iStartPos, ResultCode: Integer;
begin
   strLogWmicReult := ExpandConstant('C:\Users\Wmic_GetUserName_Result.log');

   Exec('cmd.exe', '/C wmic /node:localhost ComputerSystem Get UserName | find /V /I "UserName" >' + strLogWmicReult, '', SW_HIDE, ewWaitUntilTerminated, ResultCode);

   LoadStringFromFile(ExpandConstant(strLogWmicReult), strFileData);
   strFileData := Trim(strFileData);

   strUsNameWithDomain := LowerCase(String(strFileData));
   
   //Parse signum from FileData
   iStartPos := Pos('\', strUsNameWithDomain);
   strUserName := Copy(strUsNameWithDomain,iStartPos+1,8);
   
   DeleteFile(strLogWmicReult);

   Result := strUserName;
end;


function GetCurrentUserNameFromRegistry(): String;
var
  strUsNameWithDomain, strUserName, strLogWmicReult, strUserNameFromReg: String;
  strFileData: AnsiString;
  iStartPos, ResultCode: Integer;
begin
   RegQueryStringValue(HKEY_CURRENT_USER,
                       'Volatile Environment',
                       'USERNAME', strUserNameFromReg);

   strUserName := LowerCase(strUserNameFromReg);

   Result := strUserName;
end;


function GetCurrentInstalledPckgsFromRegistry(): String;
var
  strUsNameWithDomain, strUserName, strLogWmicReult, strUserNameFromReg: String;
  strFileData: AnsiString;
  iStartPos, ResultCode: Integer;
begin
   RegQueryStringValue(HKEY_LOCAL_MACHINE,
                       'SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall',
                       'DisplayName', strUserNameFromReg);

   strUserName := LowerCase(strUserNameFromReg);

   Result := strUserName;
end;


function NeedsAddPath(Param: string): boolean;
var
  OrigPath: string;
  rslt : boolean;
begin
  rslt := false;
  
  OrigPath := ExpandConstant(Param);
  rslt := RegQueryStringValue(HKEY_LOCAL_MACHINE,
                              'SYSTEM\CurrentControlSet\Control\Session Manager\Environment',
                              'Path', OrigPath);
  if not rslt then
  begin
    Result := True;
    exit;
  end;
end;

function NeedsAddDisplayPath(Param: string): boolean;
var
  OrigPath: string;
begin
  if not RegQueryStringValue(HKEY_CURRENT_USER,
    'Environment',
    'DISPLAY', OrigPath)
  then begin
    Result := True;
    exit;
  end;
  // look for the path with leading and trailing semicolon
  // Pos() returns 0 if not found
  Result := Pos(';' + Param + ';', ';' + OrigPath + ';') = 0;
end;
                

//Return "True" if the file found with name "strFileName" has size not zero.
function FileSizeIsNotZero(const strFileName: String): boolean;
var
  iSize: integer;
  strFullFileName: String;
  Rslt: boolean;
begin
  Rslt := false;
  strFullFileName := ExpandConstant(strFileName);

  //Returns True if the specified file exists.
  if FileExists(strFullFileName) then
    begin
      iSize := 0;
      if FileSize(strFullFileName, iSize) then
        begin
          if iSize > 0 then
            begin
              //The file is bigger than 0B in size
              Rslt := true;
            end
          else
            begin
              //The file is smaller than 0B in size
              Rslt := false;
            end;
        end
      else
        MsgBox('Reading the file size failed.', mbError, MB_OK); 
    end
  else
    Rslt := false;

  Result := Rslt;
end;


//Looking for a file "strToFind" using the "dir /b"  command redirecting result on a temporary file. 
//If the file will be not empty, means that the file qas found and then the result will be "True", 
//and remove the temporary outputfile
function IsNameInDirectory(const strToFind: String): boolean;
var
  strFullFileName, strTmpFileName: String;
  ResultCode: Integer; 
begin
  strFullFileName := ExpandConstant(strToFind);

  strTmpFileName :=  ExpandConstant('{code:NewTargetDir}\{#MyLogDir}\DirOfFile_results.txt');
  
  Exec('cmd.exe', '/C dir /b "' + strFullFileName + '" > "' + strTmpFileName + '" --silent', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);

  //If the output tmp file is not empty it means that we found some file or directory that have the searched string into their name
  Result := FileSizeIsNotZero(strTmpFileName);

  DeleteFile(strTmpFileName);
end;

//return "True" if and IDE_VM is already installed on target PC.
function IsIDE_VM_alreadyInstalled(var OccupiedMB: Cardinal): Boolean;
var
   fRslt: Boolean;
   strIDEVMDirName: String;
begin
   fRslt := false;
   //Before run "vagrant up" we have to check if a vagrant VM is already installed
   //To do this let verify if it exists a directory with name that starts with "ENM__IDE_Base*" under the <target drive>:\Users\<target signum>\VirtualBox VMs
   //First Get existing dir Names under "~\VirtualBox VMs"
   strIDEVMDirName := ExpandConstant('{code:NewTargetUserDir}\VirtualBox VMs\{#MyIDEVMName}*');
      
   //If a directory with name stat starts with "ENM_IDE_Base" is already present on directory "C:\<signum>\VirtualBox VM" an error is show
   if IsNameInDirectory(strIDEVMDirName) then
     fRslt := true;

   Result := fRslt;
end;

//Verify if free disk space on target PC is enough
function IsFreeDiskSpaceEnough(): Boolean;
var
  Path: String;
  FreeMB, TotalMB: Cardinal;
begin
  // Get and display free megabytes on the Program Files drive
  Path := ExpandConstant('{pf}');
  if GetSpaceOnDisk(Path, True, FreeMB, TotalMB) then
  begin
    MsgBox('There are ' + IntToStr(FreeMB) + ' megabytes free on ' +
      Path, mbInformation, MB_OK);
  end
  else begin
    // the function failed
  end;
end;


//Return "True" if the space on target device is enough according to requirements
function EnoughLeftSpaceOnDevice(const strDevPath: String): Boolean;
var
  strPath: String;
  FreeMB, TotalMB: Cardinal;
begin
     strPath := ExpandConstant(strDevPath);
     //Check if there is enough free space in selected drive.
     if GetSpaceOnDisk(strPath, True, FreeMB, TotalMB) then
       begin
         if FreeMB < MIN_FREE_DISK_SPACE_REQUIRED then
           begin
             MsgBox('Not enough free space on selected drive '+strPath+#13#10+
                    'Please change your target disk!', mbInformation, MB_OK);
             Result := False;
             Exit;
           end;
       end
     else
       begin
         MsgBox('Cannot read disk space on drive: '+strPath+#13#10+
                'ENM-IDE install aborted', mbInformation, MB_OK);  
         ExitProcess(0);
       end
end;

//InnoSetup default Event virtual Function that is runned before install files on target, just to allow prerequisites verify
function InitializeSetup(): Boolean;
var
  MemoryStatus: TMemoryStatusEx;
  Rslt: Boolean;
  
begin
  Rslt := True;
//  CancelWithoutPrompt := false;
//  fCanPerformVagrantUp := true;
//  fInstallGit := false;
  

  Log('InitializeSetup called');

  // that's the requirement of the function call; you must set the size
  // of the passed structure in bytes
  //MemoryStatus.dwLength := SizeOf(MemoryStatus);

  // if the GlobalMemoryStatusEx function call succeed, then...
//  if GlobalMemoryStatusEx(MemoryStatus) then
//  begin
    // if the amount of actual physical memory in bytes is less than
    // 4073,741.824 B (4 GB), then show a warning message and according
    // to user's decision abort the installation
//    if MemoryStatus.ullAvailPhys < MIN_FREE_RAM_REQUIRED then
//    begin
//      fCanPerformVagrantUp := false;
//      if MsgBox('Total Mem: '+ Int64ToStr(MemoryStatus.ullTotalPhys)+#13#10+
//                'Available Mem: '+Int64ToStr(MemoryStatus.ullAvailPhys)+#13#10+
//                'WARNING: You have not enough physical memory available to run vagrant VM !'+#13#10+
//                'Are you sure you want to continue with the installation ?', 
//                mbConfirmation, MB_YESNO) = IDNO
//      then
//        Rslt := False;
//    end;
//  end;
  

  Result := Rslt;
end;


//InnoSetup default Event virtual Function redefinition to make changes to the wizard or wizard pages at startup. 
//InitializeSetup is preparing the structure of install inputboxes and the eventual veriables where inputs must be stored
procedure InitializeWizard();
var
  PersonalPageEditIndex, FirstEditIndex, SecondEditIndex, GerritSignumPageIndex: Integer;
begin
  //This inputbox section could add the user's E/// signum on target PC. 
  //At present is configured to allow only to see which is the signum found on registry and leave to users only
  //to decide if proceed or leave the installation 
  PersonalPage := CreateInputQueryPage(wpWelcome,
                                       'Personal Information',
                                       'Here you can see what Vagrantfile-Installer have found as your username signum in your Windows PC',
                                       'Please carefully verify that your discovered signum is correct before proceed');
  
  // Add items (False means it's not a password edit)
  //Item1: Signum got from USERNAME Environment Variable set in user's Windows PC after login.
  PersonalPageEditIndex := PersonalPage.Add('Vagrantfile-Installer found that your Windows Environment variable USERNAME is:', False);
  PersonalPage.Edits[PersonalPageEditIndex].Enabled := False;
  PersonalPage.Edits[PersonalPageEditIndex].Visible := True;
  //Item2: Signum that ide-installer presume could be the same used as " Username" in Git/Gerrit
  //PersonalPageEditIndex := PersonalPage.Add('Ide-Installer found that your signum is:', False);
  //PersonalPage.Edits[PersonalPageEditIndex].Enabled := True;
  //PersonalPage.Edits[PersonalPageEditIndex].Visible := True;

  // Set initial values (optional)
  PersonalPage.Values[0] :=  GetCurrentUserNameFromRegistry;
  //PersonalPage.Values[1] :=  GetCurrentUserNameFromRegistry;



  //This section create the inputbox that could allow to change the target installation dir.
  //At present this is fixed because its parameters are configured in way that  user cannot change them
  SelectDestLocPage := CreateInputDirPage(PersonalPage.ID,
                                          'INFORMATION: Final Data Location',
                                          'Where should new data files be stored?',
                                          'Vagrantfile will be stored under the standard target path used by ENM-IDE showed below. To continue, click Next.',
                                          False,
                                          'New Folder');

  // Add item (with an empty caption)
  FirstEditIndex := SelectDestLocPage.Add('');
  SecondEditIndex := SelectDestLocPage.Add('');

  // Set initial value (optional)
  SelectDestLocPage.Values[0] := 'C:\Users\';
  SelectDestLocPage.Edits[FirstEditIndex].Enabled := False;
  SelectDestLocPage.Edits[FirstEditIndex].Visible := False;
  SelectDestLocPage.Buttons[FirstEditIndex].Hide;
  
  // Add value (with a default caption)
  SelectDestLocPage.Values[1] := 'C:\Users\';
  SelectDestLocPage.Edits[SecondEditIndex].Enabled := False;
  SelectDestLocPage.Edits[SecondEditIndex].Visible := True;
  SelectDestLocPage.Buttons[SecondEditIndex].Hide;

  
  ProgressPage := CreateOutputProgressPage('Install Application',
                                           'Install....');
end;


//Return "True" if the IE is running or not.
function IsVagrantUpRunning():  Boolean;
var ReturnCode : Integer;
  
  TmpFileName  : String;
    ExecStdout: AnsiString;
begin
   Result := False;
   TmpFileName := AddBackSlash(ExpandConstant('{tmp}')) + 'check.tmp';
   //Old: Exec('cmd.exe', '/C "FOR /F %A in (''TASKLIST /FI "IMAGENAME eq vagrant.exe" /nh'') do echo %A" > '+TmpFileName, '', SW_HIDE, ewWaitUntilTerminated, ReturnCode);
   Exec('cmd.exe', '/C "tasklist /FI "IMAGENAME eq iexplore.exe" 2>NUL | find /I /N "iexplore.exe">NUL" > '+TmpFileName, '', SW_HIDE, ewWaitUntilTerminated, ReturnCode); 
   
   if LoadStringFromFile(TmpFileName, ExecStdout) then begin
       ExecStdout := Trim(ExecStdout);
       Result := ExecStdout <> 'INFO:'; 
   end;
   DeleteFile(TmpFileName);
end;

//Return "True" if the runtime program passed as parameter is already running.
function IsProgramUpAndRun(const strProgramName: String): boolean;
var
  strLogPath, strLog, strErrorLevel, strIsNotRun: String;
  Rslt,fIsEmpty: boolean;
  ResultCode, iErrLevel: Integer;
  strFileContent: AnsiString;
  strTmp: String;
begin
  Rslt:= false;

  //Extract from input string all the parts and give in output the file name including full path. See NOTE (1) at the end
  strLogPath := ExpandConstant('{code:NewTargetDir}\{#MyLogDir}');

  //Create the temporary log directory on target path if not already exists
  if not DirExists(strLogPath) then
    Exec('cmd.exe', '/C mkdir '+strLogPath, '', SW_HIDE, ewWaitUntilTerminated, ResultCode); 
  
  strLog := ExpandConstant('{code:NewTargetDir}\{#MyLogDir}\'+strProgramName+'_IsRun_Status.log');

  //use the "tasklit" batch command  finding input program name in current running task list 
  //and redirect it on a temporary log.
  Exec('cmd.exe', '/C tasklist | findstr /I /N '+strProgramName+' > '+strLog,'', SW_HIDE, ewWaitUntilTerminated, ResultCode);
  
  fIsEmpty := FileSizeIsNotZero(strLog);

  if FileSizeIsNotZero(strLog) then
    Rslt := true;

  //Remeve the temporary log file  
  DeleteFile(strLog);
  Result := Rslt;
end;


//create a progress bar that can be configured both as time and speed.
procedure ProgressBar(const strProgressBarMsg: String; const iSleep, iCount: integer);
var
  I: integer;
begin
      ProgressPage.SetText(strProgressBarMsg, '');
      ProgressPage.SetProgress(0, 0);
      ProgressPage.Show;
      try
        for I := 0 to iCount do 
          begin
            ProgressPage.SetProgress(I, 100);
            Sleep(iSleep);
          end;
      finally
        ProgressPage.Hide;
      end;
end;


//Progress bar that has speed and progress until end that are calculated base on check if associated program is still running.
procedure ProgressBarUntilProgramRun(const strProgressBarMsg: String; const iSleep, iCount: integer; const strProgNameToCheckWileRun: String);
var
  I, iLogFileSize, j: integer;
  strFullLogFileName: String;
begin
      strFullLogFileName := ExpandConstant('{code:NewTargetUserDir}\{#MyLogDir}\{#MyLogFileForVagrantUp}');
      FileSize(strFullLogFileName, iLogFileSize);

      j := 0;
      repeat
        j := j+1;
        ProgressPage.SetText(strProgressBarMsg, 'Step: '+IntToStr(j));
        ProgressPage.SetProgress(0, 0);
        ProgressPage.Show;
        try
          for I := 0 to iCount do 
            begin
              
              ProgressPage.SetProgress(I, iCount);
              Sleep(iSleep);
            end;
        finally
          ProgressPage.Hide;
        end;
      until not IsProgramUpAndRun(strProgNameToCheckWileRun);
end;


//InnoSetup default Event virtual Function redefinition to assign global variable values using that ones got after wizard page
procedure CurPageChanged(CurPageID: Integer);
var
      I: Integer;
      strDefPath : String;
      strUserPath : String;
begin
  case CurPageID of
    SelectDestLocPage.ID:
    begin
      // this code executes for the first page, so let's setup the buttons however you want
      strDefPath := ChangeTargetDir('Signum');
      SelectDestLocPage.Values[0] := strDefPath;
                     
      strUserPath := ChangeTargetUserDir('Signum');
      SelectDestLocPage.Values[1] := strUserPath;
    end;
    wpSelectTasks:
    begin
      if fInstallGit then
      begin
        WizardForm.TasksList.Checked[5] := True;
        fInstallGit := False;
      end
      else
        WizardForm.TasksList.Checked[5] := False;
    end;
  else
    begin
    end;
  end;
end;

//verify if signum is following E/// rules
function IsAValidSignum(Param: String): boolean;
var
  strInput: String;
  iLen: integer;
  strSub: String;
begin
  Result := False;
  strInput := Param;
  iLen := Length(strInput);
  strSub := Copy(strInput,1,1);
  if (iLen <= SIGNUM_LENGTH) then
    begin
      //if (strSub = E_SIGNUM_START_LETTER) then
      if (strSub = 'e') or (strSub = 'x') or (strSub = 'q') then
        Result := True; 
    end
end;



function IsSSHAlreadyPresent(): Boolean;
var
  strSSHPath, strSSHFile, strGitBashCmd, strTmp, strLog: String;
  rslt: Boolean;
  ResultCode: Integer;
begin
     rslt := False;

     //Create the .SSH directory on target path if not already exists
     strSSHPath := ExpandConstant(SelectDestLocPage.Values[1]+'\.ssh');
     strSSHFile := ExpandConstant(SelectDestLocPage.Values[1]+'\.ssh\id_rsa.pub');
     strGitBashCmd :=  ExpandConstant('C:\Program Files (x86)\Git\bin\sh.exe');
     
     if FileOrDirExists(strSSHFile) then
       begin
         rslt := True;
       end;

   Result := rslt;
end;



procedure CreateSSH_Key();
var
  strSSHPath, strSSHFile, strGitBashCmd, strTmp, strLog, strSSHConfigName: String;
  rslt: Boolean;
  ResultCode: Integer;
  MyFile : TStrings;
  MyText : String;
begin
     MyFile := TStringList.Create;

     //Create the .SSH directory on target path if not already exists
     strSSHPath := ExpandConstant(SelectDestLocPage.Values[1]+'\.ssh');
     strSSHFile := ExpandConstant(SelectDestLocPage.Values[1]+'\.ssh\id_rsa.pub');
     strGitBashCmd :=  ExpandConstant('C:\Program Files (x86)\Git\bin\sh.exe');
     strSSHConfigName := ExpandConstant('{code:NewTargetDir}\{#MySSH_ConfigDir}');
     
     if not DirExists(strSSHPath) then
       begin
         Exec('cmd.exe', '/C echo | echo ssh-keygen -t rsa | "C:\Program Files (x86)\Git\bin\sh.exe" --login -i', '', SW_SHOW, ewWaitUntilTerminated, ResultCode);
         Exec('cmd.exe', '/C copy '+strSSHConfigName+' '+strSSHPath, '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
       end
     else 
       if not FileOrDirExists(strSSHFile) then
         begin
           Exec('cmd.exe', '/C rmdir /S /Q '+strSSHPath, '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
           Exec('cmd.exe', '/C echo | echo ssh-keygen -t rsa | "C:\Program Files (x86)\Git\bin\sh.exe" --login -i', '', SW_SHOW, ewWaitUntilTerminated, ResultCode);
           Exec('cmd.exe', '/C copy '+strSSHConfigName+' '+strSSHPath, '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
         end;
     

     MyFile.LoadFromFile(strSSHFile); 
     MyText := MyFile.Text;
     
     //Exec('cmd.exe', '/C ', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);          
     //ShellExec('', strSSHFile, '', '', SW_SHOW, ewNoWait, ResultCode);
     Exec(ExpandConstant('{win}\notepad.exe'), strSSHFile, '', SW_SHOW, ewNoWait, ResultCode);
     MsgBox('   !! A NEW SSH Key HAS BEEN GENERATED !!'+#13#10+
                'The key file is opening.....'+#13#10+
                'Select and Copy in Clipboard your SSH key code showed there'+#13#10+
                'Paste that key into "SSH Public Keys" filed in your own Gerrit settings'+#13#10+
                'Do not press "Ok" till you have not completed this activity', mbConfirmation,
                MB_OK); 
end;



function GetGitExePath(): String;
var
  strToFind, strTmpFileName: String;
  strGitExePath: String;
  MyFile : TStrings;
  MyText : string;
  ResultCode, iPos: Integer;
begin
  //Must to understand where "git.exe" has been just now installed
  strTmpFileName :=  ExpandConstant('{code:NewTargetDir}\{#MyLogDir}\GitExeFind_results.txt');
  Exec('cmd.exe', '/C where /R C:\ git.exe > ' + strTmpFileName, '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
  
  MyFile := TStringList.Create;
  MyFile.LoadFromFile(strTmpFileName); 
  MyText := MyFile.Text;
  strToFind := MyText;

  //Get the full path where "git.exe"  is located.
  iPos :=  Pos('git.exe',strToFind);
  if iPos <> 0 then
    begin
       //Get the version number of the already installed product
       strGitExePath := Copy(strToFind, 1, iPos-2);
    end;

  Result := strGitExePath;
end;



//InnoSetup Setup Event virtual functino redefinition: 
//Called when the user clicks the Next button on each input wizard boxes, a different behavious is set depending on
//what inputBox is managed, using its "PersonalPage" id.
function NextButtonClick(CurPageID: Integer): Boolean;
var
  strBuff,strPath, strLog, strTmp2: String;
  FreeMB, TotalMB: Cardinal;
  ResultCode: Integer;
begin
  Result := True;
  if CurPageID = PersonalPage.ID then
  begin 
    strBuff := PersonalPage.Values[0];
    if not IsAValidSignum(strBuff) Then
    begin
      MsgBox('Signum format not valid! Use a valid E/// signum (7 characters) i.e.:  `ebiafra`', mbInformation, MB_OK);
      Result := False;
      Exit;
    end
  end;
  if CurPageId = SelectDestLocPage.ID then
  begin
     //Check if selected drive is a valid E/// internal drive.
     strBuff := NewTargetDrivePath;
     strPath := ExpandConstant(strBuff);
     if CompareText(strBuff,'{#MyEricssonValidDrivepath}') <> 0 then
       begin
         MsgBox('Selected Target Drive is not a valid E/// encrypted disk'+strPath+#13#10+
                'Please change your target disk!', mbInformation, MB_OK);
         Result := False;
         Exit;
       end;


     //Verify if Git is already installed. If not already installed it will be automatically installed becasue otherwise the eventual
     //automatic creation of key could not works.
//     strLog := ExpandConstant('{code:NewTargetDir}\{#MyLogDir}\IsGit_Installed.log');
     
     //strTmp2 := ExpandConstant('C:\Program Files (x86)\Git\bin\git.exe');

     //Exec('cmd.exe', '/C echo "for /f "tokens=2 delims=." %F in ('+Chr(39)+strTmp2+' --version'+Chr(39)+') do echo %~F" > pippo.bat', '', SW_SHOW,ewWaitUntilTerminated, ResultCode);

     
     //Rslt := Exec('cmd.exe', ' /C "'+strTmp2+'" extpack install --replace '+S, '', SW_HIDE, ewNoWait, ResultCode);

     
//     Exec('cmd.exe', '/C for /f "tokens=2 delims=." %F in (''git.exe --version'') do echo %~F > ' + strLog, '', SW_SHOW,ewWaitUntilTerminated, ResultCode);
     
     //ProgressBar('Verify if Git is already installed...',30,100);
//     ProgressBarUntilProgramRun('Verify if Git is already installed...',10,100,'where.exe');
//     if not FileSizeIsNotZero(strLog) then
//       begin
//         rslt := false;
         //Install Git in silent mode.
         //RunGitInstaller('{code:NewTargetDir}\{#MyGitBashInstDir}\{#MyGitBashInstFile}');
         //WizardForm.TasksList.Checked[2] := True;
//         fInstallGit := True;
//       end;
//     if FileExists(strLog) then
//       DeleteFile(strLog);

     


     //Check if there is enough free space in selected drive.                            
//     if GetSpaceOnDisk(strPath, True, FreeMB, TotalMB) then
//       begin
//         if FreeMB < MIN_FREE_DISK_SPACE_REQUIRED then
//           begin
//             MsgBox('Not enough free space on selected drive '+strPath+#13#10+
//                    'Please free at least 15GB on your target disk!', mbInformation, MB_OK);
//             Result := False;
//             Exit;
//           end;
//       end
//     else
//       begin
//         MsgBox('Cannot read disk space on drive: '+strPath+#13#10+
//                'ENM-IDE install aborted', mbInformation, MB_OK);  
//         ExitProcess(0);
//       end
  end;
end;


//Read the InnoSetup global inputBox wizard parameter, copy that into a string and return that.
function GetUser(Param: String): String;
begin
  { Return a user value }
  { Could also be split into separate GetUserName and GetUserCompany functions }
  if Param = 'Signum' then
    Result := PersonalPage.Values[0]
  else 
    Result := 'Empty';

end;


//Returns the full path for IDE dir on target with the "target user"  signum
function ChangeTargetDir(Param: String): String;
var 
  s: string;
begin
  s := GetUser('Signum');

  Result := 'C:\Users\' + s + '\{#MyAppName}';
end;

//Returns the full path target dir with "target user" signum
function ChangeTargetUserDir(Param: String): String;
var 
  s: string;
begin
  s := GetUser('Signum');

  Result := 'C:\Users\' + s + '\{#MyRadixIDE_Dir}';
end;

//Get and return the target PC drive letter including its root path (i.e. :  "C:\").
function NewTargetDrivePath(): String;
var
  strSub, strInput: String;
begin
  strInput := SelectDestLocPage.Values[0];
  strSub := Copy(strInput,1,3);
  Result := strSub;
end;

//Return the full target dir string for IDE app
function NewTargetDir(Param: String): String;
begin
  Result := SelectDestLocPage.Values[0]
end;

//Return the full target user path
function NewTargetUserDir(Param: String): String;
var
  Buff: String;
begin
  Result := SelectDestLocPage.Values[1]
end;

//Function that tries to get the first file name found using dos command "dir /b", redirect that name on a temp file and returns it.
//(substituted in use by "GetFirstFileName"  that uses the "FindFirst" Pascal procedure.
function GetFileName(FileShortName: String): String;
var
  Res: Boolean;
  strFullFileName: String;
  ResultCode:   Integer;
  strTmpFileName: String;
  strFileData: AnsiString;
  strParams: String;
begin
  Res := False;
  
  strFullFileName := ExpandConstant(FileShortName);
  
  strTmpFileName :=  ExpandConstant('{code:NewTargetDir}\{#MyLogDir}\DirOrFile_results.txt');
    
  Exec('cmd.exe', '/C dir /b "' + strFullFileName + '" > "' + strTmpFileName + '" --silent', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
  
  LoadStringFromFile(strTmpFileName, strFileData);

  if FileExists(strTmpFileName) then
    DeleteFile(strTmpFileName);

  Result := strFileData;
end;


//Returns the first file name found with given prefix: the first file of a set of having name starting all with same prefix. 
function GetFirstFileName(strFileSetToFind: String): String;
var
  FindRec: TFindRec;
begin
  //Verify if not found any file with that prefix
  if (not FindFirst(strFileSetToFind, FindRec)) then
    begin
      msgbox('Cannot find a file for type: ' + strFileSetToFind + '.', mbInformation, MB_OK);
     end
  else
    //Do nothing

  Result := FindRec.Name;
end;


procedure CountNumberOfFiles(const strToFind: String);
var
  FilesFound: Integer;
  FindRec: TFindRec;
begin
  FilesFound := 0;
  if FindFirst(ExpandConstant('{sys}\*'), FindRec) then begin
    try
      repeat
        // Don't count directories
        if FindRec.Attributes and FILE_ATTRIBUTE_DIRECTORY = 0 then
          FilesFound := FilesFound + 1;
      until not FindNext(FindRec);
    finally
      FindClose(FindRec);
    end;
  end;
  MsgBox(IntToStr(FilesFound) + ' files found in the System directory.',
    mbInformation, MB_OK);
end;


function FileReplaceString(const FileName, SearchString, ReplaceString: string):boolean;
var
  MyFile : TStrings;
  MyText : string;
begin
  MyFile := TStringList.Create;

  try
    result := true;

    try     
      MyFile.LoadFromFile(FileName); 
      MyText := MyFile.Text;

      if StringChangeEx(MyText, SearchString, ReplaceString, True) > 0 then //Only save if text has been changed.
      begin;
        MyFile.Text := MyText;
        MyFile.SaveToFile(FileName);
      end;
    except
      result := false;
    end;
  finally
    MyFile.Free;
  end;
end;

function FileReplaceStringWith(const FileName, SearchString: string):boolean;
var
  MyFile : TStrings;
  MyText : string;
begin
end;

procedure FileReplaceStringWithSignum(const FileName, SearchString: string);
var
  ReplaceString : string;
  NomeFile : string;
  FileData: AnsiString;
  FileDataString: String;
  rslt: Boolean;
  iString: Integer;
begin
  ReplaceString := GetUser('Signum');

  LoadStringFromFile(ExpandConstant(FileName), FileData);

  NomeFile := ExpandConstant(FileName);

  FileDataString := String(FileData);
  if StringChangeEx(FileDataString, SearchString, ReplaceString, True) > 0 then //Only save if text has been changed.
  begin
    SaveStringToFile(ExpandConstant(FileName), FileData, False);
  end;
end;

//Replace the string "SearchString"  with another string getting all content of the file into an AnsiString
procedure FileReplaceStringWithAnother(const FileName, SearchString, ReplaceString: string);
var
  NomeFile : string;
  FileData: AnsiString;
  FileDataString: String;
  rslt: Boolean;
begin
  //Load content of the "FileName" file into an AnsiString "FileData"
  LoadStringFromFile(ExpandConstant(FileName), FileData);

  NomeFile := ExpandConstant(FileName);

  FileDataString := String(FileData);
  
  //We are going to substitute in FileDataString the string: SearchString with: ReplaceString
  if StringChangeEx(FileDataString, SearchString, ReplaceString, True) > 0 then //Only save if text has been changed.
  begin
    SaveStringToFile(ExpandConstant(FileName), FileData, False);
  end;
end;


//Substitute into pom.xml the source ide vagrant path with destination PC ide vagrant path
procedure FileReplaceSourceIdeVagrantPathWithDestVagrantPath(const FileName, SearchString: string);
var
  ReplaceString : string;
  NomeFile : string;
  FileData: AnsiString;
  FileDataString: String;
  rslt: Boolean;
begin                               
  ReplaceString := SelectDestLocPage.Values[0];
  ReplaceString := ReplaceString + '\{#MyRadixIDE_Dir}';
  
  LoadStringFromFile(ExpandConstant(FileName), FileData);

  NomeFile := ExpandConstant(FileName);
  
  FileDataString := String(FileData);

  //We are going to substitute in FileDataString the string: SearchString with: ReplaceString
  if StringChangeEx(FileDataString, SearchString, ReplaceString, True) > 0 then //Only save if text has been changed.
  begin
    SaveStringToFile(ExpandConstant(FileName), FileData, False);
  end;
  ProgressBar('Substitute path into pom.xml in progress...',30,100);
end;


function GetSystemMetrics(nIndex: Integer): Integer;
  external 'GetSystemMetrics@user32.dll stdcall';
function SendMouseInput(nInputs: UINT; pInputs: TMouseInput;
  cbSize: Integer): UINT; 
  external 'SendInput@user32.dll stdcall';

function SendMouseClick(Button: TMouseButton; X, Y: Integer): Boolean;
var
  Flags: DWORD;
  Input: TMouseInput;
  ScreenWidth: Integer;
  ScreenHeight: Integer;
begin                
  Result := False;
  Flags := MOUSEEVENTF_ABSOLUTE or MOUSEEVENTF_VIRTUALDESK or MOUSEEVENTF_MOVE;
  ScreenWidth := GetSystemMetrics(SM_CXSCREEN);
  ScreenHeight := GetSystemMetrics(SM_CYSCREEN);

  Input.Itype := INPUT_MOUSE;
  Input.dx := Round((X * 65536) / ScreenWidth);
  Input.dy := Round((Y * 65536) / ScreenHeight);
  case Button of
    mbLeft: Input.dwFlags := Flags or MOUSEEVENTF_LEFTDOWN;
    mbRight: Input.dwFlags := Flags or MOUSEEVENTF_RIGHTDOWN;
    mbMiddle: Input.dwFlags := Flags or MOUSEEVENTF_MIDDLEDOWN;
  end;  
  Result := SendMouseInput(1, Input, SizeOf(Input)) = 1;

  if Result then
  begin
    Input.Itype := INPUT_MOUSE;
    Input.dx := Round((X * 65536) / ScreenWidth);
    Input.dy := Round((Y * 65536) / ScreenHeight);
    case Button of
      mbLeft: Input.dwFlags := Flags or MOUSEEVENTF_LEFTUP;
      mbRight: Input.dwFlags := Flags or MOUSEEVENTF_RIGHTUP;
      mbMiddle: Input.dwFlags := Flags or MOUSEEVENTF_MIDDLEUP;
    end;    
    Result := SendMouseInput(1, Input, SizeOf(Input)) = 1;
  end;
end;

procedure MultiClickInstallVBox();
var i:  integer;
begin
    for i:= 1 to 5 do
    begin
      if not SendMouseClick(mbLeft, 743, 651) then 
        MsgBox(SysErrorMessage(DLLGetLastError), mbError, mb_Ok);
    end;
    if not SendMouseClick(mbLeft, 578, 481) then 
      MsgBox(SysErrorMessage(DLLGetLastError), mbError, mb_Ok);
    if not SendMouseClick(mbLeft, 743, 651) then 
      MsgBox(SysErrorMessage(DLLGetLastError), mbError, mb_Ok);
end;

function MultiClickToInstallVBox(Param: String): String;
var i:  integer;
begin
    for i:= 1 to 5 do
    begin
      if not SendMouseClick(mbLeft, 743, 651) then 
        MsgBox(SysErrorMessage(DLLGetLastError), mbError, mb_Ok);
    end;
    if not SendMouseClick(mbLeft, 578, 481) then 
      MsgBox(SysErrorMessage(DLLGetLastError), mbError, mb_Ok);
    if not SendMouseClick(mbLeft, 743, 651) then 
      MsgBox(SysErrorMessage(DLLGetLastError), mbError, mb_Ok);
  Result := 'True';
end;

procedure InstallVBox();
var strProg: String;
var winHwnd: HWND;
var retVal: Boolean;
begin
  strProg := '{#MyVBoxName}';
  winHwnd := FindWindowByWindowName(strProg);

  if winHwnd <> 0 then
    retVal:=postmessage(winHwnd,WM_KEYDOWN,0,0);

end;

//function to be customized that tries to know the processor type of target server 
//(supersided by "ProcessorArchitecture" Inno Setup predefined function)
function GetProcessorType(const Param: String): String;
var
  TmpFileName: string;
  ExecStdout: AnsiString;
  ResultCode: integer;
  CurPage : Integer;
begin
  if CurPage = wpWelcome then begin
    TmpFileName := ExpandConstant('{#MyTmpDir}') + '\GetProcType_results.txt';
    Exec('cmd.exe', '/C echo %PROCESSOR_ARCHITECTURE% > "' + TmpFileName + '"', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
    if FileExists(TmpFileName) then
    begin
      if LoadStringFromFile(TmpFileName, ExecStdout) then begin
        MsgBox(ExecStdout, mbInformation, MB_OK);
      
        // do something with contents of file...
      end;
      DeleteFile(TmpFileName);
    end;
  end;
   Result := ExecStdout;
end;

//procedure to extract .msi files from a file
procedure ExtractMSIProc(const FileExeName: String);
var
  Res: Boolean;
  strDestPath: String;
  ResultCode:   Integer;
begin
  Res := False;
  strDestPath := ExpandConstant('{code:NewTargetDir}');
  if Exec(ExpandConstant(FileExeName), ' /extract --path "' + strDestPath + '" --silent', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
    Res := True;
end;

//extract from exe file all the .msi files that could be present into that exe.
function ExtractMSI(const FileExeName: String): boolean;
var
  Res: boolean;
  strDestPath: String;
  ResultCode:   Integer;
  strCmd: String;
begin
  Res := false;
  
  //ExpandConstant extracts from input string all the parts and give in output the file name including full path. See NOTE (1) at the end  
  strDestPath := ExpandConstant('{code:NewTargetDir}\{#MyIDEVBox_Dir}');
  strCmd := ExpandConstant(FileExeName);
  
  //Execute the extraction of .msi files eventually containet into the FileExeName using the /extract option in silent mode.
  if Exec(strCmd, ' /extract --path "' + strDestPath + '" --silent', '', SW_HIDE, ewWaitUntilTerminated, ResultCode) then
    begin
      Res := true;
    end
  else
    begin                                                              
       //ExtractMSIProc for FileExeName NOT completed on: strDestPath
    end;

  Result := Res;
end;


function RemoveNullFromStr(const loc: AnsiString):String;
//const 
//  ALPHA_CHARS = ['a'..'z', 'A'..'Z'];
var
  Alphabet: String;
  i, j, k, iLen:Integer;
  strLoc, strTmp : String;
begin
   Alphabet := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890.';
   iLen := length(loc);
   strLoc := '';
   j := 1;
   k := 1;
   For i:=1 to iLen do
   begin
     strTmp := loc[i];
     if strTmp=#0 then
       //do nothing
       k := k+1
     else
       if Pos(strTmp,Alphabet) = 0 then
         //do nothing
         k := k +1
     else
       begin
         strLoc := strLoc+strTmp;
         j := j+1;
       end;
   end;

   Result := strLoc;
end;



function RemoveCharFromStr(const strSource: String; const strToBeRemoved: String):String;
//const 
//  ALPHA_CHARS = ['a'..'z', 'A'..'Z'];
var
  strAlphabet: String;
  i, j, k, iLen:Integer;
  strLoc, strTmp : String;
begin
   strAlphabet := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890';
   iLen := length(strSource);
   strLoc := '';
   j := 1;
   k := 1;
   For i:=1 to iLen do
   begin
     strTmp := strSource[i];
     if CompareStr(strTmp, strToBeRemoved) = 0 then
       //do nothing
       k := k+1
     else
       if Pos(strTmp,strAlphabet) = 0 then
         //do nothing
         k := k +1
     else
       begin
         strLoc := strLoc+strTmp;
         j := j+1;
       end;
   end;

   Result := strLoc;
end;




//find the version of a given product if already installe don the target PC 
function GetVersionOfProductIfAlreadyInstalled(const Str: String; var fIsInstalled: Boolean; const strVerToBeInst: String): String;
var 
  fIsEmpty, Rslt: boolean;
  strToFind, strLog, strLogPath, strCmd, strVer: String;
  ResultCode: integer;
  TmpFileName: string;
  strFileData: AnsiString;
  S: TArrayOfString;
begin
  fIsInstalled := False;
  //Log temporary file to be used to redirect output results of batch command
  strLog := ExpandConstant('{code:NewTargetDir}\{#MyLogDir}\IsProgram_Installed.log');
  strLogPath := ExpandConstant('{code:NewTargetDir}\{#MyLogDir}');
  if not DirExists(strLogPath) then
    Rslt := Exec('cmd.exe', '/C mkdir '+strLogPath+'\log', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
  
  //Prepare "wmic" command to Get version of "VitualBox" if a VBox is already present and redirect it to a temporary log file
  //Command is:  wmic product where "name like '%VirtualBox%'" get Version
  strToFind := 'Name like '+'''%'+ Str + '%''';
  strCmd := 'wmic product where "' + strToFind + '" get Version';
  //Get version of "VitualBox"  if a VBox is already present and redirect it to a temporary log file
  Rslt := Exec('cmd.exe',' /C '+ strCmd + ' > ' + strLog, '', SW_HIDE, ewNoWait, ResultCode);
  ProgressBarUntilProgramRun('Verify if VirtualBox is already installed...',30,300,'wmic.exe');
  
  if FileExists(strLog) then
  begin
    fIsEmpty := FileSizeIsNotZero(strLog);

    if FileSizeIsNotZero(strLog) then
    begin
      Rslt := true;
      //Read the Version number of installed package from file
      LoadStringsFromFile(strLog, S);
      LoadStringFromFile(strLog, strFileData);
      strFileData := Trim(strFileData);
      strFileData := RemoveNullFromStr(strFileData);
      strToFind := String(strFileData);
      //if the file contains the string "Version" means that some version of the "Str" product has been found with wmic as already installed
      if Pos('Version',strToFind) <> 0 then
        begin
          //Get the version number of the already installed product
          strVer := Copy(strToFind, 8, 6);
          
          //If the version to be installed is different from that currently under install ask to user, otherwise proceed anywhere.
          //if CompareStr(strVer, strVerToBeInst) = 0 then
          //If the  strVer  is not empty it means that a VirtualBox versio is already installed on PC
          if length(strVer) <> 0 then
            fIsInstalled := True; 
        end;
    end;

    //Remeve the temporary log file
    DeleteFile(strLog);
  end;

  Result := strVer;
end;


function IsAMoreRecentVersionAlreadyInstalled(const strVerAlreadyPresent: String; const strVerToBeInst: String): Boolean;
var
  i, j, k, p, iLen, iVerAlrPr, iVerToBeInst: integer;
  strNumber, strVerAlrPr, strVerToInst, strTmp: string;
   
begin
  strNumber := '1234567890';
  //Parsing version's string of already installed product (4.3.36)
  iLen := length(strVerAlreadyPresent);
  
  j := 1;
  k := 1;
  For i:=1 to iLen do
  begin
     strTmp := strVerAlreadyPresent[i];
     if Pos(strTmp, strNumber) = 0 then
       begin
         //se il carattere in esame rappresenta un numero, lo converto in integer
         //strVerAlrPr[j] := strTmp;
         j := j+1;
       end;
  
     strTmp := strVerToBeInst[i];
     if Pos(strTmp, strNumber) = 0 then
       begin
         //se il carattere in esame rappresenta un numero, lo converto in integer
         //strVerToInst[k] := strTmp;
         k := k+1;
       end;

     //p := Pos('.',strVerAlreadyPresent); 
     //if p <> 0 then
     //  begin
     //    //Get the version number of the already installed product
     //    strVer := Copy(strVerAlreadyPresent, p-1, 1);
     //  end;
  end;

  iVerAlrPr := StrToInt(strVerAlrPr);
  iVerToBeInst := StrToInt(strVerToInst);
end;


//verify if VirtualBox is already installed and if yes, ask user if proceed or not.
function VerifyIfToBeInstalled(const fIsAlreadyInstalled: Boolean; const strVerAlreadyPresent: String; const strVerToBeInst: String; const S: String): Boolean;
var 
  Rslt, fRunInstall: boolean;
  ResultCode: integer;
  strVB: string;
begin
  Rslt := True;
  fRunInstall := True;
  
  if fIsAlreadyInstalled then
    begin
      fRunInstall := False;

      if CompareStr(strVerAlreadyPresent, strVerToBeInst) > 0 then
        begin
          if MsgBox('    "VirtualBox installation" WARNING!    '+#13#10+
                    'a more recent version of VirtualBox is already present on target!'+#13#10+
                    'IDE can work also with that but may not start if some personal specific configuration is present'+#13#10+ 
                    'Do you want to overwrite that?', mbConfirmation,
                    MB_YESNO) = IDYES then 
            begin
              fRunInstall := True;
              //strVB := ExpandConstant('{code:NewTargetDir}\{#MyIDEVBox_Dir}\' + strMSIFileName);
              //Exec('msiexec',' /x ' + S + ' /qb', '', SW_SHOW, ewWaitUntilTerminated, ResultCode);
              //msiexec /x ProductName.msi /qb
            end
          else
            begin
              //msgbox('    Install of IDE terminated!    ' , mbInformation, MB_OK);
              //CancelWithoutPrompt := true;
              //WizardForm.Close;
            end;
        end;
    end;
  
  
  if fRunInstall then
    begin
       Rslt := Exec('msiexec',' /i ' + S + ' REINSTALLMODE=amus /quiet /passive /norestart', '', SW_SHOW, ewWaitUntilTerminated, ResultCode);
       fInstallVBox := True;
    end
  else
    fInstallVBox := False;


  Result := Rslt;
end;


//install VirtaulBox using .msi file in case of target has an 64bit processor type
procedure InstallVBox64();
var S: String;
    strWorkingDir: String;
    strFileSetToFind, strVerToBeInst, strVerAlreadyPresent: String;
    strMSIFileName: String;
    ResultCode, iStart:   Integer;
    Rslt, fIsAlreadyInst: boolean;
    FindRec: TFindRec;
begin
  fIsAlreadyInst := False;
  //strFileSetToFind is a string that includes the set of files to be looking for in the dest directory where just copied by [FILE] section.
  strFileSetToFind := SelectDestLocPage.Values[0] + '\{#MyIDEVBox_Dir}\Virt*64.msi';
  
  //Use the GetFirst pascal procedure to list all versions of the set of files of type to be found and take the first one. 
  strMSIFileName := GetFirstFileName(strFileSetToFind);
  
  //The "GetFirstFileName" returns only the name of the file found, losing the full path. So we need to attach path again to execute it.
  S := ExpandConstant('{code:NewTargetDir}\{#MyIDEVBox_Dir}\' + strMSIFileName);
  strWorkingDir := ExpandConstant('{code:NewTargetDir}\{#MyIDEVBox_Dir}');

  //Extract version from current msi file Name
  iStart := Pos('-',strMSIFileName); 
  if iStart <> 0 then
    strVerToBeInst := Copy(strMSIFileName, iStart+1,6); 
  //run the file found as a DOS command, without waiting answer, and in silent (/quiet) mode and without asking restart at the end (/norestart): 
  //In this case the options are valid only for ".msi"  installers and we expect that it was compiled using "msiexec".    
  strVerAlreadyPresent := GetVersionOfProductIfAlreadyInstalled('VirtualBox',fIsAlreadyInst,strVerToBeInst);

  //If is already installed ask user if proceed or not
  Rslt := VerifyIfToBeInstalled(fIsAlreadyInst, strVerAlreadyPresent, strVerToBeInst, S);
end;

//install VirtaulBox using .msi file in case of target has an x86 processor type
procedure InstallVBoxX86();
var S: String;
    WorkingDir: String;
    strFileSetToFind: String;
    strMSIFileName, strVerToBeInst, strVerAlreadyPresent: String;
    strWorkingDir: String;
    ResultCode, iStart:   Integer;
    Rslt, fIsAlreadyInst: boolean;
begin
  fIsAlreadyInst := False;
  //strFileSetToFind is a string that includes the set of files to be looking for in the dest directory where just copied by [FILE] section.
  strFileSetToFind := SelectDestLocPage.Values[0] + '\{#MyIDEVBox_Dir}\Virt*x86.msi';
  
  //Use the GetFirst pascal procedure to list all versions of the set of files of type to be found and take the first one. 
  strMSIFileName := GetFirstFileName(strFileSetToFind);

  //The "GetFirstFileName" returns only the name of the file found, losing the full path. So we need to attach path again to execute it.
  S := ExpandConstant('{code:NewTargetDir}\{#MyIDEVBox_Dir}\' + strMSIFileName);
  strWorkingDir := ExpandConstant('{code:NewTargetDir}\{#MyIDEVBox_Dir}');

  //Extract version from current msi file Name
  iStart := Pos('-',strMSIFileName); 
  if iStart <> 0 then
    strVerToBeInst := Copy(strMSIFileName, iStart+1,6); 
  //run the file found as a DOS command, without waiting answer, and in silent (/quiet) mode and without asking restart at the end (/norestart): 
  //In this case the options are valid only for ".msi"  installers and we expect that it was compiled using "msiexec".    
  strVerAlreadyPresent := GetVersionOfProductIfAlreadyInstalled('VirtualBox',fIsAlreadyInst,strVerToBeInst);
  
  //If is already installed ask user if proceed or not
  Rslt := VerifyIfToBeInstalled(fIsAlreadyInst, strVerAlreadyPresent, strVerToBeInst, S);
end;


//Global procedure that is able to install VirtualBox into several different kind of target platforms
procedure RunVBoxInstaller(const File: String);
var
  ResultCode: Integer;  
  S: String;
  strFullNameFile: String;
  strS : String;
  strExactFullFileName : String;
  FindRec: TFindRec;
begin
  strFullNameFile := ExpandConstant(File);
  
  strS := GetFirstFileName(strFullNameFile);
  //GG Fix
  strExactFullFileName := SelectDestLocPage.Values[0] + '\{#MyIDEVBox_Dir}\' + strS;

  //Extract the .msi files from the .exe installer of VirtualBox.  
  if ExtractMSI(strExactFullFileName) then
    begin
      case ProcessorArchitecture of
        paX86: 
          begin
            InstallVBoxX86;
            S := 'x86';
          end;
        paX64: 
          begin
            InstallVBox64;
            S := 'x64';
          end;
        paIA64: 
          begin
            InstallVBox64;
            S := 'Itanium';
          end;
      else
        begin
          S := 'Unrecognized';
          msgbox('Unrecognized Processor Architecture!', mbInformation, MB_OK);
        end;
      end;
    end
  else
    begin
      msgbox('False: myapplication.exe : ' + SysErrorMessage(ResultCode), mbInformation, MB_OK);   //Debug    
    end;                        
end;



//find the version of a given product if already installe don the target PC 
function IsVBoxExtPackAlreadyInstalled(const Str: String; const strVerToBeInst: String): Boolean;
var 
  fIsEmpty, Rslt, fIsInstalled: boolean;
  strTmp2, strToFind, strLog, strLogPath, strCmd, strVBExtPackDir: String;
  ResultCode: integer;
  TmpFileName: string;
  strFileData: AnsiString;
  S: TArrayOfString;
begin
  //TODO
  //If the VirtualBox is already installed we suppose that the correct associated ExtPack desired by user is already present itself
  if fInstallVBox then
    fIsInstalled := True;
  
  //Let have to verify if there is the directory:  C:\Program Files\Oracle\VirtualBox\ExtensionPacks\Oracle_VM_VirtualBox_Extension_Pack
  strVBExtPackDir := ExpandConstant('{#MyVBoxDir}\ExtensionPacks\Oracle_VM_VirtualBox_Extension_Pack');
  if not DirExists(strVBExtPackDir) then
    fIsInstalled := False;


  Result := fIsInstalled;
end;




//Global procedure that is able to install VirtualBox into several different kind of target platforms    GIAN
procedure RunVBoxPackInstaller(const File: String);
var
  ResultCode: Integer;  
  S: String;
  strFullNameFile: String;
  strS, strTmp2 : String;
  strWorkingDir : String;
  FindRec: TFindRec;
begin
  strFullNameFile := ExpandConstant(File);
  
  strS := GetFirstFileName(strFullNameFile);
  
  //The "GetFirstFileName" returns only the name of the file found, losing the full path. So we need to attach path again to execute it.
  S := ExpandConstant('{code:NewTargetDir}\{#MyIDEVBox_Dir}\' + strS);
  strWorkingDir := ExpandConstant('{code:NewTargetDir}\{#MyIDEVBox_Dir}');

  strTmp2 := ExpandConstant('C:\Program Files\Oracle\VirtualBox\VBoxManage.exe');

  //use VBoxManage to install in silent mode the extention pack
  if fInstallVBox then
    begin
      Rslt := Exec('cmd.exe', ' /C "'+strTmp2+'" extpack install --replace '+S, '', SW_HIDE, ewNoWait, ResultCode);
      ProgressBar('Installing VirtualBox Ext Pack.....',50,300);
    end;
end;








//install in silent mode the Git client for Windows on target PC.
procedure RunGitInstaller(const strFile: String);
var
  ResultCode, iPos: Integer;  
  S: String;
  strFullNameFileToFind, strGitFileName, strUserSignum, strUserNameMail, strTmpFileName: String;
  strWorkingDir, strPath, strOrigPath, strNewPath, strToFind, strGitCmd: String;
  Rslt: boolean;
  Page: TInputQueryWizardPage;
  strFileData: AnsiString;
  strS: TArrayOfString;
  MyFile : TStrings;
  MyText : string;
begin
  //strFile is a string that includes the set of files to be looking for in the dest directory where just copied by [FILE] section.
  //Extract from input string all the parts and give in output the file name including full path. See NOTE (1) at the end
  strFullNameFileToFind := ExpandConstant(strFile);

  //Use the GetFirst pascal procedure to list all versions of the set of files of type to be found and take the first one. 
  strGitFileName := GetFirstFileName(strFullNameFileToFind);
  
  //The "GetFirstFileName" returns only the name of the file found, losing the full path. So we need to attach path again to execute it.
  S := ExpandConstant('{code:NewTargetDir}\{#MyGitBashInstDir}\' + strGitFileName);
  strWorkingDir := ExpandConstant('{code:NewTargetDir}\{#MyGitBashInstDir}');
  
  //run the file found as a DOS command, without waiting answer, and in silent (/S) mode: if the file in string "S" is an installer will be run
  //In this case the "/S" option is an option valid only for installers compiled using Wise and we expect that it was compiled using "Wise" .
  Rslt := Exec(S,' /SILENT', '', SW_SHOW, ewWaitUntilTerminated, ResultCode);


  //Evaluate if need to add git\bin to ststem env variable %PATH%
  //strGitInstalledBinPath := ExpandConstant('C:\Program Files (x86)\Git\cmd');


  //Must to understand where "git.exe" has been just now installed
  strPath := GetGitExePath();

//  strTmpFileName :=  ExpandConstant('{code:NewTargetDir}\{#MyLogDir}\GitExeFind_results.txt');
//  Exec('cmd.exe', '/C where /R C:\ git.exe > ' + strTmpFileName, '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
  
//  MyFile := TStringList.Create;
//  MyFile.LoadFromFile(strTmpFileName); 
//  MyText := MyFile.Text;
//  strToFind := MyText;
  //Get the full path where "git.exe"  is located.
//  iPos :=  Pos('git.exe',strToFind);
//  if iPos <> 0 then
//    begin
       //Get the version number of the already installed product
//       strPath := Copy(strToFind, 1, iPos-2);
//    end;


  //Update path in Registry adding Git path.
  //if  NeedsAddPath(strPath) then
  //  begin
      RegQueryStringValue(HKEY_LOCAL_MACHINE,
                          'SYSTEM\CurrentControlSet\Control\Session Manager\Environment',
                          'Path', strOrigPath);
      strNewPath := ExpandConstant(strOrigPath+';'+strPath);
      RegWriteStringValue(HKEY_LOCAL_MACHINE,
                          'SYSTEM\CurrentControlSet\Control\Session Manager\Environment',
                          'Path', strNewPath);
  //  end;

  //TODO
  //git config --global user.name "Your Name"
  strUserSignum := GetUser('Signum');
  strGitCmd := ExpandConstant(strPath+'\git.exe');
  Exec('cmd.exe', '/C '+strGitCmd+' config --global user.name '+strUserSignum, '', SW_SHOW, ewWaitUntilTerminated, ResultCode);
end;




//install in silent mode the X server "VcXsrv" for Windows on target PC.
procedure InstallVcXsrv(const strFile: String);
var S: String;
    strVcXsrvFileName: String;
    strFullNameFileToFind: String;
    strWorkingDir: String;
    ResultCode:   Integer;
    Rslt: boolean;
begin
  //strFile is a string that includes the set of files to be looking for in the dest directory where just copied by [FILE] section.
  //Extract from input string all the parts and give in output the file name including full path. See NOTE (1) at the end
  strFullNameFileToFind := ExpandConstant(strFile);

  //Use the GetFirst pascal procedure to list all versions of the set of files of type to be found and take the first one. 
  strVcXsrvFileName := GetFirstFileName(strFullNameFileToFind);
  
  //The "GetFirstFileName" returns only the name of the file found, losing the full path. So we need to attach path again to execute it.
  S := ExpandConstant('{code:NewTargetDir}\{#MyIDExcsrv_Dir}\' + strVcXsrvFileName);
  strWorkingDir := ExpandConstant('{code:NewTargetDir}\{#MyIDExcsrv_Dir}');
  
  // msgbox('InstallVCXsrc! StringToBeExecuted: ' + S + '!!', mbInformation, MB_OK);  //Debug

  //run the file found as a DOS command, without waiting answer, and in silent (/S) mode: if the file in string "S" is an installer will be run
  //In this case the "/S" option is an option valid only for installers compiled using Wise and we expect that it was compiled using "Wise" .
  Rslt := Exec(S,' /S', '', SW_SHOW, ewNoWait, ResultCode);
end;

//call the "InstallVcXsrv" priocedure to install X server "VcXsrv" on target pc  showing a progress bar
procedure RunVcXsrvInstaller(const File: String);
var
  ResultCode: Integer;  
  S: String;
  I: integer;
begin
    //The input "File"  is a string that contains the full path and the "filter name" of the set of files where the file you're looking for belongs.
    InstallVcXsrv(File);
    ProgressBar('Install of VcXsrv in progress...',30,100);
end;

//install in silent mode the "Vagrant" toolset for Windows on target PC.
procedure RunVagrantInstaller(const strFile: String);
var S: String;
    strVagrantFileName: String;
    strFullNameFileToFind: String;
    strWorkingDir: String;
    ResultCode:   Integer;
    Rslt: boolean;
begin
  //strFile is a string that includes the set of files to be looking for in the dest directory where just copied by [FILE] section.
  //Extract from input string all the parts and give in output the file name including full path. See NOTE (1) at the end
  strFullNameFileToFind := ExpandConstant(strFile);

  //Use the GetFirst pascal procedure to list all versions of the set of files of type to be found and take the first one. 
  strVagrantFileName := GetFirstFileName(strFullNameFileToFind);
  
  //The "GetFirstFileName" returns only the name of the file found, losing the full path. So we need to attach path again to execute it.  
  S := ExpandConstant('{code:NewTargetDir}\Vagrant\' + strVagrantFileName);
  
  //run the file found as a DOS command, without waiting answer, and in silent (/quiet) mode and without asking restart at the end (/norestart): 
  //In this case the options are valid only for ".msi"  installers and we expect that it was compiled using "msiexec".  
  strWorkingDir := ExpandConstant('{code:NewTargetDir}\Vagrant');
  Rslt := Exec('msiexec',' /i ' + S + ' /quiet /passive /norestart', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
end;


//install in silent mode the "Vagrant" toolset for Windows on target PC.
procedure RunVdhResizerInstaller(const strFile: String);
var S: String;
    strVhdResizerFileName: String;
    strFullNameFileToFind: String;
    strWorkingDir: String;
    ResultCode:   Integer;
    Rslt: boolean;
begin
  //strFile is a string that includes the set of files to be looking for in the dest directory where just copied by [FILE] section.
  //Extract from input string all the parts and give in output the file name including full path. See NOTE (1) at the end
  strFullNameFileToFind := ExpandConstant(strFile);

  //Use the GetFirst pascal procedure to list all versions of the set of files of type to be found and take the first one. 
  strVhdResizerFileName := GetFirstFileName(strFullNameFileToFind);
  
  //The "GetFirstFileName" returns only the name of the file found, losing the full path. So we need to attach path again to execute it.  
  S := ExpandConstant('{code:NewTargetDir}\{#MyIDEvhdReizer_TargerDir}\' + strVhdResizerFileName);
  
  //run the file found as a DOS command, without waiting answer, and in silent (/quiet) mode and without asking restart at the end (/norestart): 
  //In this case the options are valid only for ".msi"  installers and we expect that it was compiled using "msiexec".  
  strWorkingDir := ExpandConstant('{code:NewTargetDir}\{#MyIDEvhdReizer_TargerDir}');
  Rslt := Exec('msiexec',' /i ' + S + ' /quiet /passive /norestart', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
end;


//Description:
//Queries the specified REG_SZ- or REG_EXPAND_SZ-type value, and returns the data in ResultStr. Returns True if successful. When False is returned, ResultStr is unmodified.
//   function RegQueryStringValue(const RootKey: Integer; const SubKeyName, ValueName: String; var ResultStr: String): Boolean;
//Example:
//var
//  Country: String;
//begin
//  if RegQueryStringValue(HKEY_CURRENT_USER, 'Control Panel\International',
//     'sCountry', Country) then
//  begin
//    // Successfully read the value
//    MsgBox('Your country: ' + Country, mbInformation, MB_OK);
//  end;
//end;

//InnoSetup standard virtual method that can be used for future scopes to customize the uninstall.
procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
begin
  if CurUninstallStep = usUninstall then begin
    if MsgBox('Do you want to delete all data files?', mbConfirmation,
        MB_YESNO) = IDYES 
    then begin
      //DeleteBitmaps(ExpandConstant('{app}'));
      //Search
      //You should be able to read the uninstall string from the registry, given the AppId (i.e. the value you used for AppID in the
      //[Setup]-section). 
      //It could be found under Software\Microsoft\Windows\CurrentVersion\Uninstall\{AppId}\ (could be either HKLM or HKCU, so best check both)
      //where {AppId} should be substituted with the actual value you used. Look for the UninstallString or QuietUninstallString values and use
      //the Exec function to run it from your InitializeSetup() event function.
      //Update: removed non-working alternative solution using a [Run]-section entry with {uninstallexe}
    end;
  end;
end;

//runs the VirtualBox present on targe PC
procedure RunVBox(const strVBoxFileName: String);
var
  ResultCode:   Integer;
  Rslt: boolean;  
  strIDEName: String;
begin
  //To run the just installed Vagrant in Headless mode:
  //"C:\Program Files\Oracle\VirtualBox\VBoxManage.exe" setextradata "ENM_IDE_Base" GUI/Seamless on
  //"C:\Program Files\Oracle\VirtualBox\VBoxManage.exe" startvm "ENM_IDE_Base" -type headless
  strIDEName := '{#MyIDEVMName}';
 
  Rslt := Exec(strVBoxFileName,' setextradata ' + strIDEName + ' GUI/Seamless on', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
  Rslt := Exec(strVBoxFileName,' startvm ' + strIDEName + ' -type headless', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
end;


//runs a "vagrant destroy" in case of need to clean an already existing ENM_IDE_Base installed on target PC
procedure PerformVagrantDestroy(const strIdePath:  String);
var
  strLog: String;
  strLogPath: String;
  strLogFileName: String;
  strIdeTargetPath: String;
  strWin64CurlPath: String;
  ResultCode,I,iSize:   Integer;
  Rslt: boolean;
  strDestName: String;
begin
  Rslt := true;
  //strFile is a string that includes the set of files to be looking for in the dest directory where just copied by [FILE] section.
  //Extract from input string all the parts and give in output the file name including full path. See NOTE (1) at the end
  strIdeTargetPath := ExpandConstant(strIdePath);
  
  strLog :=  ExpandConstant('{code:NewTargetDir}\{#MyLogDir}\Out_Chdir.log');
  Exec('cmd.exe', '/C cd '+strIdeTargetPath+' & vagrant destroy -f > '+strLog, '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
  if FileExists(strLog) then
    DeleteFile(strLog);
  ProgressBar('Destroy previous existing Vagrant VM In progress...',30,100);
end;


//Create on the fly on target Windows PC a windows batch script that is able to configure and start the new IDE.
procedure CreateVagrantUpBatchOnTargetPC(const strIdePath:  String);
var
  strFullLogFileName: String;
  strIDEVMDirName: String;
  strIdeVagrantfileTargetPath: String;
  strVagrantUpBatchFileName: String;
  ResultCode,I,iSize, ReturnCode:   Integer;
  Rslt: boolean;
  strDestName: String;
  strTmp1, strTmp2: String;
begin
  Rslt := false;

  strIdeVagrantfileTargetPath := ExpandConstant(strIdePath);
    
  strFullLogFileName := ExpandConstant('{code:NewTargetDir}\{#MyLogDir}\{#MyLogFileForVagrantUp}');

  strVagrantUpBatchFileName := ExpandConstant('{code:NewTargetDir}\{#MyRunVagrantUpBatch}');
                                                                       
  Exec('cmd.exe', '/C echo "cd '+strIdeVagrantfileTargetPath+' & vagrant up --debug 2> '+strFullLogFileName+'" > '+strVagrantUpBatchFileName, '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
  FileReplaceString(strVagrantUpBatchFileName, '"', '');
end;


//execute checks and ask info to user to prepare the run of Vagrant IDE VM in a clean and correct environment
procedure PrepareToPerformVagrantUp(const strIdePath:  String);
var
  strLog, TmpFileName, strIDEVMDir, strUserSignum, strGitreposDir: String;
  strLogPath: String;
  strIDEVMDirName: String;
  strIdeVagrantfileTargetPath: String;
  strWin64CurlPath: String;
  ResultCode,I,iSize, ReturnCode:   Integer;
  Rslt: boolean;
  strDestName: String;
  strTmp1, strTmp2, strGetVagranfileBatchName: String;
  strGitBash, strGitCmd: String;
begin
  Rslt := false;
  fPerformVagrantUp := False;


  //First verify if .ssh is already present and if not generate that
  //IsSSHAlreadyPresent;
  if not IsSSHAlreadyPresent then
    begin
      if MsgBox('   !! WARNING !!    '+#13#10+
                'SSH key not found in your Windows PC'+#13#10+
                'IDE cannot run without ~/.ssh/id_rsa.pub key file'+#13#10+
                'Press "Yes" if you want to automatically generate that now'+#13#10+
                'IMPORTANT: if you choose "No" you have to manually create that'+#13#10+
                '           before run IDE, otherwise IDE will not work properly', mbConfirmation,
                MB_YESNO) = IDYES 
      then
        begin
          CreateSSH_Key;
          fCanPerformVagrantUp := true;
        end
      else
        fCanPerformVagrantUp := false;
     end;    

  //*** GET LATEST VAGRANFTILE FROM GERRIT ***           
  //strFile is a string that includes the set of files to be looking for in the dest directory where just copied by [FILE] section.
  //Extract from input string all the parts and give in output the file name including full path. See NOTE (1) at the end
  strIdeVagrantfileTargetPath := ExpandConstant(strIdePath);
  strUserSignum := GetUser('Signum');
  strGitreposDir := ExpandConstant('{code:NewTargetUserDir}\{#MyRadixIDE_Dir}');
  //Convert string path from DOS format to Unix format: substitute "\"  with "/"
  if StringChangeEx(strGitreposDir, '\', '/', True) > 0 then //Only get Vagrantfile if text has been changed. Otherwise it won't work..
    begin
      strGetVagranfileBatchName := ExpandConstant('{code:NewTargetDir}\{#MyGetVagrantFileBatch}');

      //TODO:  non e' detto che Git venga installato sotto la Program Files (x86). Bisogna usare la funzione vista sopra con wmic
      Exec('cmd.exe', '/C echo "C:\Program Files (x86)\Git\bin\sh.exe" --login -i -c "cd '+strGitreposDir+' && echo -ne ''\ny'' | git archive --remote=ssh://'+strUserSignum+'@gerrit.ericsson.se:29418/OSS/com.ericsson.de/ide.git HEAD:vagrant Vagrantfile | tar -x" > '+strGetVagranfileBatchName, '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
      Exec('cmd.exe','/C '+strGetVagranfileBatchName,'', SW_HIDE, ewNoWait, ResultCode);
      ProgressBar('Get latest VagrantFile In progress...',30,100);
    end
  else
    MsgBox('Failure on getting last version of Vagrantfile!!'+#13#10+
           'Before to press "OK" button, please open a git bash and run manually following commands:'+#13#10+
           '1)  cd ~/gitrepos/ide/vagrant'+#13#10+
           '2)  git archive --remote=ssh://'+strUserSignum+'@gerrit.ericsson.se:29418/OSS/com.ericsson.de/ide.git HEAD:vagrant Vagrantfile | tar -x', 
            mbInformation, MB_OK);  //Debug
  
    
  if fCanPerformVagrantUp then
  begin
   CreateVagrantUpBatchOnTargetPC(strIdePath);
   //Prepare target environment to run vagrant up automatically or using icon: if not present Create directory where put "vagrant up" log output
   strLogPath := ExpandConstant('{code:NewTargetDir}\{#MyLogDir}');
   if not DirExists(strLogPath) then
     Rslt := Exec('cmd.exe', '/C mkdir '+strLogPath+'\log', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);

   if MsgBox('Do you want to automatically create ENM_IDE VM?'+#13#10+
            '(the command "vagrant up" will be executed in background)', mbConfirmation,
        MB_YESNO) = IDYES 
    then begin
      fPerformVagrantUp := True;

      strIDEVMDirName := ExpandConstant('{code:NewTargetUserDir}\VirtualBox VMs\{#MyIDEVMName}');
      
      //If a directory with name stat starts with "ENM_IDE_Base" is already present on directory "C:\<signum>\VirtualBox VM" an error is show
      //if IsNameInDirectory(strIDEVMDirName) then
      if DirExists(strIDEVMDirName) then
        begin
          if MsgBox('    WARNING!!!'+#13#10+
                 'An ENM_IDE VM is already installed or partially present on target PC.'+#13#10+
                 'You have to uninstall that before run vagrant up'+#13#10+
                 'Perform uninstall oldest VM now?'+#13#10+
                 '(If you choice "No" the "vagrant up" will be executed on the already installed IDE VM)', mbConfirmation, MB_YESNO) = IDYES 
          then
            begin
              PerformVagrantDestroy(strIdeVagrantfileTargetPath);
              
              //Check if VM has been successfully removed. If not an error message will be displayed and end installation.
              if IsNameInDirectory(strIDEVMDirName) then
                begin
                  strIDEVMDir := ExpandConstant('{code:NewTargetUserDir}\{#MyVirtualBoxVMDirName}');
                  strTmp1 := ExpandConstant('{#MyIDEVMName}*');
                  strTmp2 := ExpandConstant('C:\Program Files\Oracle\VirtualBox');
                  
                  //Check if there is a subdirectory under "VirtualBox VMs" with name starting with "ENM_IDE_Base" and perform the clean remove of that subdir using VBoxMamage command
                  Exec('cmd.exe', '/C cd '+strIDEVMDir+' & for /D %f in ('+strTmp1+') do "'+strTmp2+'\VBoxManage.exe" unregistervm %f --delete', '', SW_SHOW, ewWaitUntilTerminated, ResultCode);
                  //MsgBox('  Info!'+#13#10+'  current path is: '+IntToStr(ResultCode)+'!', mbConfirmation, MB_OK);
                  
                  if IsNameInDirectory(strIDEVMDirName) then
                    begin
                      //MsgBox('  Info!'+#13#10+'  vagrant destroy result is: '+IntToStr(ResultCode)+'!', mbConfirmation, MB_OK);

                      //If "Vagrant Remove"  failed, it tries to remove manually all "strIDEVMDirName"s
                      //Rslt := Exec('cmd.exe', '/C FOR /D /R %X IN ('+strIDEVMDirName+') DO RD /S /Q %X > '+strIDEVMDir+'\result.txt', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
                      Rslt := Exec('cmd.exe', '/C cd '+strIDEVMDir+' & for /D %f in ('+strTmp1+') do rd /S /Q %f', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
                      if (ResultCode <> 0) then
                        begin
                          fPerformVagrantUp := False;
                          MsgBox('      ERROR!'+#13#10+
                                 'Destroy of ENM_IDE failed!'+#13#10+
                                 'Vagrant-Up could not be executed', mbInformation, MB_OK);
                        end;
                    end;
                end;
            end
          else
            begin
              fPerformVagrantUp := True;
              strTmp2 := ExpandConstant('{code:NewTargetUserDir}\{#MyRadixIDE_Dir}');
            end;
        end;
    end
   else
    begin
      strTmp2 := ExpandConstant('{code:NewTargetUserDir}\{#MyRadixIDE_Dir}');
      msgbox('          VAGRANT VM NOT YET CREATED!      '+#13#10+
                   'You can do it manually after this install has finished'+#13#10+
                   'Open a shell and move at this path: '+strTmp2+#13#10+
                   'Then type "vagrant up"', mbInformation, MB_OK);
    end;
  end
  else
    msgbox('    VAGRANT MACHINE WILL NOT BE CREATED NOW!!  '+#13#10+
           'You can do it manually after this install has finished', mbInformation, MB_OK); 

    //Execute command to add into the target PC the Ericsson AB certificare for ide-installer
    //Exec('cmd.exe', '/C certutil.exe -f -user -addstore Root ..\src\cert\IDE_Installer.cer | C:\Users\egiogiu\Downloads\nircmd\nircmd.exe dlg "" "" click Yes', '', SW_SHOW, ewWaitUntilTerminated, ResultCode);

    //Exec('cmd.exe', '/C echo start /b /WAIT certutil.exe -f -user -addstore Root {code:NewTargetDir}\{#MyCertificateDir}\{#MyIDEInstallerCertificate} > {#MyBaseDir}\{#My3PPSourceDir}\{#MyAppName}_{#MyAppVersion}\{#MyAppName}_{#MyAppVersion}.bat', '', SW_HIDE, ewNoWait, ResultCode);
    //Exec('cmd.exe', '/C echo call {code:NewTargetDir}\{#MyNirCmdDir} dlgany "" "" click Yes >> {#MyBaseDir}\{#My3PPSourceDir}\{#MyAppName}_{#MyAppVersion}\{#MyAppName}_{#MyAppVersion}.bat', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
    //Exec('cmd.exe', '/C echo {#MyAppName}_{#MyAppVersion}.exe >> {#MyBaseDir}\{#My3PPSourceDir}\{#MyAppName}_{#MyAppVersion}\{#MyAppName}_{#MyAppVersion}.bat', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
    //Exec('cmd.exe', '/C ..\target\makecert.exe -r -sv IDE_Installer.pvk -n "CN=c Ericsson AB 2016 -2024, O=Ericsson PDU NAM, L=Genova, S=Italy, C=IT" IDE_Installer.cer -b 01/01/2016 -e 12/31/2024', '', SW_SHOW, ewNoWait, ResultCode);
    //Exec('cmd.exe', '/C ..\target\nircmd.exe dlgany "" "" click Ok', '', SW_SHOW, ewNoWait, ResultCode);
    //Exec('cmd.exe', '/C ..\target\nircmd.exe dlgany "" "" click Yes', '', SW_SHOW, ewNoWait, ResultCode);
end;        


//if called is able to update the "cuerl.exe"  on target PC if not already present.
procedure UpdateCurlIfNeed(const strIdePath:  String);
var
  strLog, TmpFileName: String;
  strLogPath: String;
  strIDEVMDirName: String;
  strIdeVagrantfileTargetPath: String;
  strWin64CurlPath: String;
  ResultCode,I,iSize, ReturnCode:   Integer;
  Rslt: boolean;
   strDestName: String;
begin
  Rslt := false;
  strLogPath := ExpandConstant('{code:NewTargetDir}');
  
  //Before perform vagrant up we have to check if the "curl.exe" installed with Vagrant is compatible with the S.O. on target PC
  //To check this we try to use that " curl.exe" with a default standard command that should always run.
  //If it fails, the downloaded file will be empty, and the system is win64, it means that the "curl.exe" installed in vagrant is not actually for 64bit but for 32bit
  //Then we have to substitute it with the "mingw64"  version of the curl.exe.
  Exec('cmd.exe', '/C C:\HashiCorp\Vagrant\embedded\bin\curl.exe http://www.google.com > ' + strLogPath + '\google_com.html 2>&1', '', SW_HIDE, ewWaitUntilTerminated, ResultCode); 

  Rslt := FileSizeIsNotZero(strLogPath + '\google_com.html');
   

  if (not Rslt) then
    begin
      strWin64CurlPath := ExpandConstant('{code:NewTargetDir}\{#MyWin64CurlDir}');
      
      Exec('cmd.exe', '/C copy ' + strWin64CurlPath + '\curl.exe C:\HashiCorp\Vagrant\embedded\bin\curl.exe', '', SW_HIDE, ewWaitUntilTerminated, ResultCode);      
      ProgressBar('Copy curl64bit in progress...',30,100);
    end;

end;


//return global variable that after checks can tell if the vagrant startup command can be run or not
function IsVagrantUpToBePerformed(): Boolean;
begin
  Result := fPerformVagrantUp;
end;


//if called perform the vagrant startup on target PC
procedure PerformVagrantUp(const strIdePath:  String);
var
  strFullLogFileName: String;
  strIdeVagrantfileTargetPath: String;
  ResultCode,I,iSize:   Integer;
  strVagrantPath: String;
begin
  //strFile is a string that includes the set of files to be looking for in the dest directory where just copied by [FILE] section.
  //Extract from input string all the parts and give in output the file name including full path. See NOTE (1) at the end
  strIdeVagrantfileTargetPath := ExpandConstant(strIdePath);
    
  strFullLogFileName := ExpandConstant('{code:NewTargetDir}\{#MyLogDir}\{#MyLogFileForVagrantUp}');

  //Open a Git Bash
  //Redirect this into a Git bash
  strVagrantPath := ExpandConstant('C:\HashiCorp\Vagrant\bin');

  //Execute the "vagrant up" on a dos shell
  Exec('cmd.exe', '/C cd '+strIdeVagrantfileTargetPath+' & ' + strVagrantPath + '\vagrant up --debug 2> '+strFullLogFileName, '', SW_SHOW, ewWaitUntilTerminated, ResultCode);

  if  ResultCode <> 0 then
     msgbox('    "Vagrant up" ERROR!    '+#13#10+
            'Vagrant IDE VM not correctly created!'+#13#10+
            'See log file at '+strFullLogFileName, mbInformation, MB_OK); 
end;






//NOTE:
//(1)-
   //"ExpandConstant" interpretate any part of input string that includes a code function (i.e. '{code:NewTargetDir}'
   //and then activate the function contained into the string getting (in this case) the full target path and concatenate
   //it to the other patrs of the input string (in thos case the name of the file)
